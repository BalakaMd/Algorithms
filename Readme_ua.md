# Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком
У цьому проекті ми розробляли структуру даних однозв'язний список та реалізували різні операції з ним, такі як вставка, видалення, пошук елемента, а також реверсування, сортування та об'єднання відсортованих списків.

`ex_1.py`: В цьому файлі міститься визначення класів Node та LinkedList, які представляють вузли та однозв'язний список відповідно. Визначені методи включають вставку в початок і кінець списку, вставку після заданого вузла, видалення вузла за значенням ключа, пошук елемента за значенням, виведення списку на екран, а також методи для реверсування, сортування та об'єднання списків.
___
# Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії

Ця програма на Python використовує рекурсію для створення фрактала "дерево Піфагора". Фрактал "дерево Піфагора" виглядає як дерево, де кожна гілка розбивається на дві менші гілки, що утворюють кут 45 градусів з основною гілкою.

### Вимоги

1. Python 3.x
2. Turtle модуль (стандартний модуль Python)

### Як використовувати

1. Запустіть програму за допомогою команди `python ex_2.py`.
2. Введіть рівень рекурсії (ціле число), щоб задати складність фрактала "дерево Піфагора".
3. Натисніть будь-яку клавішу або клікніть мишею у вікні, щоб закрити вікно з фракталом.
___
# Завдання 3. Дерева, алгоритм Дейкстри

Цей файл містить реалізацію алгоритму Дейкстри на мові Python з використанням бінарної купи для знаходження
найкоротших шляхів у зваженому графі. Ця реалізація працює тільки з графами без ваг від'ємного значення.


### Використання

1. Запустіть Python імпортуючи функцію `dijkstra` з файлу `ex_3.py`.
2. Визначте граф, для якого потрібно знайти найкоротші шляхи.
3. Викличте функцію `dijkstra(graph, start_vertex)`, передавши граф та початкову вершину.

### Приклад

```python
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
start_vertex = 'A'
print(dijkstra(graph, start_vertex))
```
___
# Завдання 4. Візуалізація піраміди

У цьому завданні ми використовуємо Python для побудови та візуалізації бінарної купи за допомогою бібліотеки NetworkX та matplotlib.


1. Заданий код у файлі `ex_4.py` реалізує побудову бінарних дерев та їх візуалізацію.

2. Задача полягає в тому, щоб модифікувати цей код для побудови та візуалізації максимальної бінарної купи.

### Залежності

- Python 3.x
- Бібліотеки:
  - NetworkX
  - matplotlib

Встановіть бібліотеки за допомогою pip:

```bash
pip install networkx matplotlib
```
___
# Завдання 5. Візуалізація обходу бінарного дерева

Цей проект містить код для візуалізації бінарного дерева за допомогою бібліотеки NetworkX та Matplotlib. Також в проекті реалізовані обходи дерева в глибину (DFS) та в ширину (BFS), які демонструються на візуалізованому дереві.

### Вимоги

Перед запуском коду переконайтеся, що встановлені наступні пакети:

- Python (рекомендовано використовувати версію 3.x)
- NetworkX
- Matplotlib

Ви можете встановити ці пакети, використовуючи pip:

```bash
pip install networkx matplotlib
```
### Пояснення кольорів
У візуалізації кожен вузол має власний колір, який позначається у порядку обходу. Кольори генеруються автоматично, щоб кожен вузол мав унікальний колір.
___
# Завдання 6: Жадібні алгоритми та динамічне програмування

Це завдання полягає у написанні програми на Python, яка реалізує два підходи — жадібний алгоритм та алгоритм динамічного програмування для вибору їжі з найбільшою сумарною калорійністю в межах обмеженого бюджету.

У цьому завданні надається словник `items`, який містить дані про різні види їжі. Кожен вид їжі представлений у вигляді словника з вартістю і калорійністю. Задача полягає в тому, щоб вибрати певні види їжі так, щоб їх сумарна калорійність була максимальною, але при цьому не перевищувала обмеженого бюджету.

### Жадібний алгоритм

У жадібному алгоритмі спочатку сортується список предметів за їх відношенням калорій до вартості, а потім вибираються предмети у порядку спадання цього відношення до тих пір, поки сумарна вартість не перевищить бюджет.

### Алгоритм динамічного програмування

У цьому підході використовується динамічне програмування для обчислення оптимального набору страв для максимізації калорійності при заданому бюджеті. Для цього створюється двовимірний масив `k`, де `k[i][j]` представляє максимальну калорійність, яку можна отримати з перших `i` предметів за умови, що загальна вартість не перевищує `j`.
___
# Завдання 7: Використання методу Монте-Карло

## Опис завдання
Необхідно написати програму на Python, яка імітує велику кількість кидків кубиків, обчислює суми чисел, які випадають на кубиках, і визначає ймовірність кожної можливої суми. На основі проведених імітацій створити таблицю або графік, який відображає ймовірності кожної суми, виявлені за допомогою методу Монте-Карло. Порівняти отримані результати з аналітичними розрахунками.

## Результати симуляції

### За допомогою методу Монте-Карло

| Сума | Імовірність    |
|------|----------------|
| 2    | 2.79% (27870/1000000)   |
| 3    | 5.55% (55479/1000000)   |
| 4    | 8.32% (83248/1000000)   |
| 5    | 11.08% (110804/1000000)  |
| 6    | 13.93% (139259/1000000)  |
| 7    | 16.61% (166148/1000000)  |
| 8    | 13.93% (139282/1000000)  |
| 9    | 11.11% (111142/1000000)  |
| 10   | 8.36% (83584/1000000)   |
| 11   | 5.55% (55533/1000000)   |
| 12   | 2.77% (27651/1000000)   |

### Аналітичні результати

| Сума | Імовірність    |
|------|----------------|
| 2    | 2.78% (1/36)   |
| 3    | 5.56% (2/36)   |
| 4    | 8.33% (3/36)   |
| 5    | 11.11% (4/36)  |
| 6    | 13.89% (5/36)  |
| 7    | 16.67% (6/36)  |
| 8    | 13.89% (5/36)  |
| 9    | 11.11% (4/36)  |
| 10   | 8.33% (3/36)   |
| 11   | 5.56% (2/36)   |
| 12   | 2.78% (1/36)   |

## Висновки

Результати симуляції за допомогою методу Монте-Карло добре узгоджуються з аналітичними розрахунками. Це підтверджує ефективність методу Монте-Карло для апроксимації ймовірностей в експериментальних умовах.


